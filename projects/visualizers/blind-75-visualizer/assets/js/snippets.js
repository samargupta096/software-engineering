/**
 * Collection of all 75 Blind 75 Problems organized into 10 Categories
 */

window.BLIND_75_SNIPPETS = {
    'array': [
        { shortTitle: 'Two Sum', snippet: `class Solution {\n  public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    return new int[] {};\n  }\n}` },
        { shortTitle: 'Buy & Sell Stock', snippet: `class Solution {\n  public int maxProfit(int[] prices) {\n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n    for (int price : prices) {\n      if (price < minPrice) minPrice = price;\n      else if (price - minPrice > maxProfit) maxProfit = price - minPrice;\n    }\n    return maxProfit;\n  }\n}` },
        { shortTitle: 'Contains Duplicate', snippet: `class Solution {\n  public boolean containsDuplicate(int[] nums) {\n    Set<Integer> set = new HashSet<>();\n    for (int num : nums) {\n      if (!set.add(num)) return true;\n    }\n    return false;\n  }\n}` },
        { shortTitle: 'Product of Array Except Self', snippet: `class Solution {\n  public int[] productExceptSelf(int[] nums) {\n    int n = nums.length;\n    int[] res = new int[n];\n    res[0] = 1;\n    for (int i = 1; i < n; i++) res[i] = res[i - 1] * nums[i - 1];\n    int right = 1;\n    for (int i = n - 1; i >= 0; i--) {\n      res[i] *= right;\n      right *= nums[i];\n    }\n    return res;\n  }\n}` },
        { shortTitle: 'Max Subarray', snippet: `class Solution {\n  public int maxSubArray(int[] nums) {\n    int maxSoFar = nums[0], maxEndingHere = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n      maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]);\n      maxSoFar = Math.max(maxSoFar, maxEndingHere);\n    }\n    return maxSoFar;\n  }\n}` },
        { shortTitle: 'Max Product Subarray', snippet: `class Solution {\n  public int maxProduct(int[] nums) {\n    if (nums.length == 0) return 0;\n    int maxSoFar = nums[0], minSoFar = nums[0], result = maxSoFar;\n    for (int i = 1; i < nums.length; i++) {\n      int curr = nums[i];\n      int tempMax = Math.max(curr, Math.max(maxSoFar * curr, minSoFar * curr));\n      minSoFar = Math.min(curr, Math.min(maxSoFar * curr, minSoFar * curr));\n      maxSoFar = tempMax;\n      result = Math.max(maxSoFar, result);\n    }\n    return result;\n  }\n}` },
        { shortTitle: 'Find Min in Rotated Array', snippet: `class Solution {\n  public int findMin(int[] nums) {\n    int left = 0, right = nums.length - 1;\n    while (left < right) {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] > nums[right]) left = mid + 1;\n      else right = mid;\n    }\n    return nums[left];\n  }\n}` },
        { shortTitle: 'Search Rotated Array', snippet: `class Solution {\n  public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] == target) return mid;\n      if (nums[left] <= nums[mid]) {\n        if (target >= nums[left] && target < nums[mid]) right = mid - 1;\n        else left = mid + 1;\n      } else {\n        if (target > nums[mid] && target <= nums[right]) left = mid + 1;\n        else right = mid - 1;\n      }\n    }\n    return -1;\n  }\n}` },
        { shortTitle: '3Sum', snippet: `class Solution {\n  public List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> res = new ArrayList<>();\n    for (int i = 0; i < nums.length - 2; i++) {\n      if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n        int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\n        while (lo < hi) {\n          if (nums[lo] + nums[hi] == sum) {\n            res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\n            while (lo < hi && nums[lo] == nums[lo + 1]) lo++;\n            while (lo < hi && nums[hi] == nums[hi - 1]) hi--;\n            lo++; hi--;\n          } else if (nums[lo] + nums[hi] < sum) lo++;\n          else hi--;\n        }\n      }\n    }\n    return res;\n  }\n}` },
        { shortTitle: 'Container With Most Water', snippet: `class Solution {\n  public int maxArea(int[] height) {\n    int maxarea = 0, l = 0, r = height.length - 1;\n    while (l < r) {\n      maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));\n      if (height[l] < height[r]) l++;\n      else r--;\n    }\n    return maxarea;\n  }\n}` }
    ],
    'binary': [
        { shortTitle: 'Sum of Two Integers', snippet: `class Solution {\n  public int getSum(int a, int b) {\n    while (b != 0) {\n      int carry = a & b;\n      a = a ^ b;\n      b = carry << 1;\n    }\n    return a;\n  }\n}` },
        { shortTitle: 'Number of 1 Bits', snippet: `class Solution {\n  public int hammingWeight(int n) {\n    int count = 0;\n    while (n != 0) {\n      n &= (n - 1);\n      count++;\n    }\n    return count;\n  }\n}` },
        { shortTitle: 'Counting Bits', snippet: `class Solution {\n  public int[] countBits(int num) {\n    int[] f = new int[num + 1];\n    for (int i=1; i<=num; i++) f[i] = f[i >> 1] + (i & 1);\n    return f;\n  }\n}` },
        { shortTitle: 'Missing Number', snippet: `class Solution {\n  public int missingNumber(int[] nums) {\n    int missing = nums.length;\n    for (int i = 0; i < nums.length; i++) {\n      missing ^= i ^ nums[i];\n    }\n    return missing;\n  }\n}` },
        { shortTitle: 'Reverse Bits', snippet: `public class Solution {\n  public int reverseBits(int n) {\n    int result = 0;\n    for (int i = 0; i < 32; i++) {\n      result += n & 1;\n      n >>>= 1;\n      if (i < 31) result <<= 1;\n    }\n    return result;\n  }\n}` }
    ],
    'dp': [
        { shortTitle: 'Climbing Stairs', snippet: `class Solution {\n  public int climbStairs(int n) {\n    if (n <= 2) return n;\n    int[] dp = new int[n + 1];\n    dp[1] = 1; dp[2] = 2;\n    for (int i = 3; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2];\n    return dp[n];\n  }\n}` },
        { shortTitle: 'Coin Change', snippet: `class Solution {\n  public int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n    for (int i = 1; i <= amount; i++) {\n      for (int coin : coins) {\n        if (coin <= i) dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n  }\n}` },
        { shortTitle: 'Longest Inc. Subseq.', snippet: `class Solution {\n  public int lengthOfLIS(int[] nums) {\n    if (nums.length == 0) return 0;\n    int[] dp = new int[nums.length];\n    Arrays.fill(dp, 1);\n    int max = 1;\n    for (int i = 1; i < nums.length; i++) {\n      for (int j = 0; j < i; j++) {\n        if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);\n      }\n      max = Math.max(max, dp[i]);\n    }\n    return max;\n  }\n}` },
        { shortTitle: 'LCS', snippet: `class Solution {\n  public int longestCommonSubsequence(String text1, String text2) {\n    int[][] dp = new int[text1.length() + 1][text2.length() + 1];\n    for (int i = 1; i <= text1.length(); i++) {\n      for (int j = 1; j <= text2.length(); j++) {\n        if (text1.charAt(i - 1) == text2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + 1;\n        else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n      }\n    }\n    return dp[text1.length()][text2.length()];\n  }\n}` },
        { shortTitle: 'Word Break', snippet: `class Solution {\n  public boolean wordBreak(String s, List<String> wordDict) {\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 1; i <= s.length(); i++) {\n      for (int j = 0; j < i; j++) {\n        if (dp[j] && wordDict.contains(s.substring(j, i))) {\n          dp[i] = true;\n          break;\n        }\n      }\n    }\n    return dp[s.length()];\n  }\n}` },
        { shortTitle: 'Comb. Sum IV', snippet: `class Solution {\n  public int combinationSum4(int[] nums, int target) {\n    int[] dp = new int[target + 1];\n    dp[0] = 1;\n    for (int i = 1; i <= target; i++) {\n      for (int num : nums) {\n        if (i - num >= 0) dp[i] += dp[i - num];\n      }\n    }\n    return dp[target];\n  }\n}` },
        { shortTitle: 'House Robber', snippet: `class Solution {\n  public int rob(int[] nums) {\n    if (nums.length == 0) return 0;\n    if (nums.length == 1) return nums[0];\n    int[] dp = new int[nums.length];\n    dp[0] = nums[0];\n    dp[1] = Math.max(nums[0], nums[1]);\n    for (int i = 2; i < nums.length; i++) dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n    return dp[nums.length - 1];\n  }\n}` },
        { shortTitle: 'House Robber II', snippet: `class Solution {\n  public int rob(int[] nums) {\n    if (nums.length == 1) return nums[0];\n    return Math.max(robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1));\n  }\n  private int robRange(int[] nums, int start, int end) {\n    int t1 = 0, t2 = 0;\n    for (int i = start; i <= end; i++) {\n      int temp = t1;\n      t1 = Math.max(nums[i] + t2, t1);\n      t2 = temp;\n    }\n    return t1;\n  }\n}` },
        { shortTitle: 'Decode Ways', snippet: `class Solution {\n  public int numDecodings(String s) {\n    if (s == null || s.length() == 0) return 0;\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1; dp[1] = s.charAt(0) != '0' ? 1 : 0;\n    for (int i = 2; i <= n; i++) {\n      int first = Integer.valueOf(s.substring(i - 1, i));\n      int second = Integer.valueOf(s.substring(i - 2, i));\n      if (first >= 1 && first <= 9) dp[i] += dp[i - 1];\n      if (second >= 10 && second <= 26) dp[i] += dp[i - 2];\n    }\n    return dp[n];\n  }\n}` },
        { shortTitle: 'Unique Paths', snippet: `class Solution {\n  public int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int i = 0; i < m; i++) dp[i][0] = 1;\n    for (int j = 0; j < n; j++) dp[0][j] = 1;\n    for (int i = 1; i < m; i++) {\n      for (int j = 1; j < n; j++) {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n    return dp[m - 1][n - 1];\n  }\n}` },
        { shortTitle: 'Jump Game', snippet: `class Solution {\n  public boolean canJump(int[] nums) {\n    int reachable = 0;\n    for(int i=0; i<nums.length; ++i) {\n      if(i > reachable) return false;\n      reachable = Math.max(reachable, i + nums[i]);\n    }\n    return true;\n  }\n}` }
    ],
    'graph': [
        { shortTitle: 'Clone Graph', snippet: `class Solution {\n  public Node cloneGraph(Node node) {\n    if (node == null) return null;\n    Map<Node, Node> map = new HashMap<>();\n    Queue<Node> queue = new LinkedList<>();\n    queue.add(node);\n    map.put(node, new Node(node.val, new ArrayList<>()));\n    while (!queue.isEmpty()) {\n      Node h = queue.poll();\n      for (Node neighbor : h.neighbors) {\n        if (!map.containsKey(neighbor)) {\n          map.put(neighbor, new Node(neighbor.val, new ArrayList<>()));\n          queue.add(neighbor);\n        }\n        map.get(h).neighbors.add(map.get(neighbor));\n      }\n    }\n    return map.get(node);\n  }\n}` },
        { shortTitle: 'Course Schedule', snippet: `class Solution {\n  public boolean canFinish(int numCourses, int[][] prerequisites) {\n    int[] indegree = new int[numCourses];\n    List<List<Integer>> adj = new ArrayList<>();\n    for (int i = 0; i < numCourses; i++) adj.add(new ArrayList<>());\n    for (int[] pre : prerequisites) {\n      adj.get(pre[1]).add(pre[0]);\n      indegree[pre[0]]++;\n    }\n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) if (indegree[i] == 0) q.offer(i);\n    int count = 0;\n    while (!q.isEmpty()) {\n      int curr = q.poll();\n      count++;\n      for (int next : adj.get(curr)) {\n        if (--indegree[next] == 0) q.offer(next);\n      }\n    }\n    return count == numCourses;\n  }\n}` },
        { shortTitle: 'Pac Atl Water Flow', snippet: `class Solution {\n  int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};\n  public List<List<Integer>> pacificAtlantic(int[][] matrix) {\n    List<List<Integer>> res = new ArrayList<>();\n    if (matrix == null || matrix.length == 0) return res;\n    int m = matrix.length, n = matrix[0].length;\n    boolean[][] pac = new boolean[m][n], atl = new boolean[m][n];\n    for (int i = 0; i < m; i++) { dfs(matrix, pac, i, 0); dfs(matrix, atl, i, n-1); }\n    for (int j = 0; j < n; j++) { dfs(matrix, pac, 0, j); dfs(matrix, atl, m-1, j); }\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (pac[i][j] && atl[i][j]) res.add(Arrays.asList(i, j));\n      }\n    }\n    return res;\n  }\n  private void dfs(int[][] matrix, boolean[][] visited, int i, int j) {\n    visited[i][j] = true;\n    for (int[] d : dir) {\n      int r = i + d[0], c = j + d[1];\n      if (r < 0 || r >= matrix.length || c < 0 || c >= matrix[0].length || visited[r][c] || matrix[r][c] < matrix[i][j]) continue;\n      dfs(matrix, visited, r, c);\n    }\n  }\n}` },
        { shortTitle: 'Number of Islands', snippet: `class Solution {\n  public int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) return 0;\n    int count = 0;\n    for (int i = 0; i < grid.length; i++) {\n      for (int j = 0; j < grid[0].length; j++) {\n        if (grid[i][j] == '1') {\n          dfs(grid, i, j);\n           count++;\n        }\n      }\n    }\n    return count;\n  }\n  private void dfs(char[][] grid, int i, int j) {\n    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') return;\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1);\n  }\n}` },
        { shortTitle: 'Longest Cons. Seq.', snippet: `class Solution {\n  public int longestConsecutive(int[] nums) {\n    Set<Integer> set = new HashSet<>();\n    for (int n : nums) set.add(n);\n    int max = 0;\n    for (int num : set) {\n      if (!set.contains(num - 1)) {\n        int curr = num;\n        int currStreak = 1;\n        while (set.contains(curr + 1)) {\n          curr += 1;\n          currStreak += 1;\n        }\n        max = Math.max(max, currStreak);\n      }\n    }\n    return max;\n  }\n}` },
        { shortTitle: 'Alien Dictionary', snippet: `class Solution {\n  public String alienOrder(String[] words) {\n    Map<Character, List<Character>> adj = new HashMap<>();\n    Map<Character, Integer> counts = new HashMap<>();\n    for (String word : words) for (char c : word.toCharArray()) counts.put(c, 0);\n    for (int i = 0; i < words.length - 1; i++) {\n      String word1 = words[i], word2 = words[i + 1];\n      if (word1.length() > word2.length() && word1.startsWith(word2)) return "";\n      for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) {\n        if (word1.charAt(j) != word2.charAt(j)) {\n          adj.computeIfAbsent(word1.charAt(j), k -> new ArrayList<>()).add(word2.charAt(j));\n          counts.put(word2.charAt(j), counts.get(word2.charAt(j)) + 1);\n          break;\n        }\n      }\n    }\n    Queue<Character> q = new LinkedList<>();\n    for (char c : counts.keySet()) if (counts.get(c) == 0) q.add(c);\n    StringBuilder sb = new StringBuilder();\n    while (!q.isEmpty()) {\n      char c = q.poll();\n      sb.append(c);\n      if (adj.containsKey(c)) {\n        for (char next : adj.get(c)) {\n          counts.put(next, counts.get(next) - 1);\n          if (counts.get(next) == 0) q.add(next);\n        }\n      }\n    }\n    if (sb.length() < counts.size()) return "";\n    return sb.toString();\n  }\n}` },
        { shortTitle: 'Graph Valid Tree', snippet: `class Solution {\n  public boolean validTree(int n, int[][] edges) {\n    if (edges.length != n - 1) return false;\n    int[] root = new int[n];\n    for (int i = 0; i < n; i++) root[i] = i;\n    for (int[] e : edges) {\n      int root0 = find(root, e[0]);\n      int root1 = find(root, e[1]);\n      if (root0 == root1) return false;\n      root[root1] = root0;\n    }\n    return true;\n  }\n  private int find(int[] root, int e) {\n    if (root[e] == e) return e;\n    return root[e] = find(root, root[e]);\n  }\n}` },
        { shortTitle: 'Count Components', snippet: `class Solution {\n  public int countComponents(int n, int[][] edges) {\n    int[] root = new int[n];\n    for (int i = 0; i < n; i++) root[i] = i;\n    int count = n;\n    for (int[] e : edges) {\n      int r1 = find(root, e[0]), r2 = find(root, e[1]);\n      if (r1 != r2) {\n        root[r1] = r2;\n        count--;\n      }\n    }\n    return count;\n  }\n  private int find(int[] root, int id) {\n    while (id != root[id]) {\n      root[id] = root[root[id]];\n      id = root[id];\n    }\n    return id;\n  }\n}` }
    ],
    'interval': [
        { shortTitle: 'Insert Interval', snippet: `class Solution {\n  public int[][] insert(int[][] intervals, int[] newInterval) {\n    List<int[]> result = new ArrayList<>();\n    int i = 0, n = intervals.length;\n    while (i < n && intervals[i][1] < newInterval[0]) result.add(intervals[i++]);\n    while (i < n && intervals[i][0] <= newInterval[1]) {\n      newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n      newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n      i++;\n    }\n    result.add(newInterval);\n    while (i < n) result.add(intervals[i++]);\n    return result.toArray(new int[result.size()][]);\n  }\n}` },
        { shortTitle: 'Merge Intervals', snippet: `class Solution {\n  public int[][] merge(int[][] intervals) {\n    if (intervals.length <= 1) return intervals;\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    List<int[]> result = new ArrayList<>();\n    int[] current = intervals[0];\n    result.add(current);\n    for (int[] interval : intervals) {\n      if (current[1] >= interval[0]) current[1] = Math.max(current[1], interval[1]);\n      else { current = interval; result.add(current); }\n    }\n    return result.toArray(new int[result.size()][]);\n  }\n}` },
        { shortTitle: 'Non-overlap Interv.', snippet: `class Solution {\n  public int eraseOverlapIntervals(int[][] intervals) {\n    if(intervals.length == 0) return 0;\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\n    int end = intervals[0][1], count = 1;\n    for(int i = 1; i < intervals.length; i++) {\n      if(intervals[i][0] >= end) {\n        end = intervals[i][1];\n        count++;\n      }\n    }\n    return intervals.length - count;\n  }\n}` },
        { shortTitle: 'Meeting Rooms', snippet: `class Solution {\n  public boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    for (int i = 0; i < intervals.length - 1; i++) {\n        if (intervals[i][1] > intervals[i + 1][0]) return false;\n    }\n    return true;\n  }\n}` },
        { shortTitle: 'Meeting Rooms II', snippet: `class Solution {\n  public int minMeetingRooms(int[][] intervals) {\n    int[] starts = new int[intervals.length];\n    int[] ends = new int[intervals.length];\n    for(int i=0; i<intervals.length; i++) {\n      starts[i] = intervals[i][0]; ends[i] = intervals[i][1];\n    }\n    Arrays.sort(starts); Arrays.sort(ends);\n    int rooms = 0, endsItr = 0;\n    for(int i=0; i<starts.length; i++) {\n      if(starts[i] < ends[endsItr]) rooms++;\n      else endsItr++;\n    }\n    return rooms;\n  }\n}` }
    ],
    'linked-list': [
        { shortTitle: 'Reverse Linked List', snippet: `class Solution {\n  public ListNode reverseList(ListNode head) {\n    ListNode prev = null, curr = head;\n    while (curr != null) {\n      ListNode nextNode = curr.next;\n      curr.next = prev;\n      prev = curr;\n      curr = nextNode;\n    }\n    return prev;\n  }\n}` },
        { shortTitle: 'Linked List Cycle', snippet: `public class Solution {\n  public boolean hasCycle(ListNode head) {\n    if (head == null) return false;\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n      slow = slow.next;\n      fast = fast.next.next;\n      if (slow == fast) return true;\n    }\n    return false;\n  }\n}` },
        { shortTitle: 'Merge Two Lists', snippet: `class Solution {\n  public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(-1);\n    ListNode curr = dummy;\n    while (l1 != null && l2 != null) {\n      if (l1.val <= l2.val) { curr.next = l1; l1 = l1.next; }\n      else { curr.next = l2; l2 = l2.next; }\n      curr = curr.next;\n    }\n    curr.next = l1 == null ? l2 : l1;\n    return dummy.next;\n  }\n}` },
        { shortTitle: 'Merge K Lists', snippet: `class Solution {\n  public ListNode mergeKLists(ListNode[] lists) {\n    if (lists == null || lists.length == 0) return null;\n    PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n    for (ListNode list : lists) if (list != null) pq.add(list);\n    ListNode dummy = new ListNode(-1), curr = dummy;\n    while (!pq.isEmpty()) {\n      curr.next = pq.poll();\n      curr = curr.next;\n      if (curr.next != null) pq.add(curr.next);\n    }\n    return dummy.next;\n  }\n}` },
        { shortTitle: 'Remove Nth Node', snippet: `class Solution {\n  public ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode first = dummy, second = dummy;\n    for (int i = 1; i <= n + 1; i++) first = first.next;\n    while (first != null) {\n      first = first.next;\n      second = second.next;\n    }\n    second.next = second.next.next;\n    return dummy.next;\n  }\n}` },
        { shortTitle: 'Reorder List', snippet: `class Solution {\n  public void reorderList(ListNode head) {\n    if (head == null) return;\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n      slow = slow.next;\n      fast = fast.next.next;\n    }\n    ListNode prev = null, curr = slow, temp;\n    while (curr != null) {\n      temp = curr.next;\n      curr.next = prev;\n      prev = curr;\n      curr = temp;\n    }\n    ListNode first = head, second = prev;\n    while (second.next != null) {\n      temp = first.next;\n      first.next = second;\n      first = temp;\n      temp = second.next;\n      second.next = first;\n      second = temp;\n    }\n  }\n}` }
    ],
    'matrix': [
        { shortTitle: 'Set Matrix Zeroes', snippet: `class Solution {\n  public void setZeroes(int[][] matrix) {\n    boolean firstRow = false, firstCol = false;\n    for (int i = 0; i < matrix.length; i++) {\n      for (int j = 0; j < matrix[0].length; j++) {\n        if (matrix[i][j] == 0) {\n          if (i == 0) firstRow = true;\n          if (j == 0) firstCol = true;\n          matrix[0][j] = 0; matrix[i][0] = 0;\n        }\n      }\n    }\n    for (int i = 1; i < matrix.length; i++) {\n      for (int j = 1; j < matrix[0].length; j++) {\n        if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;\n      }\n    }\n    if (firstRow) for (int j = 0; j < matrix[0].length; j++) matrix[0][j] = 0;\n    if (firstCol) for (int i = 0; i < matrix.length; i++) matrix[i][0] = 0;\n  }\n}` },
        { shortTitle: 'Spiral Matrix', snippet: `class Solution {\n  public List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> res = new ArrayList<>();\n    if (matrix.length == 0) return res;\n    int rowBegin = 0, rowEnd = matrix.length - 1, colBegin = 0, colEnd = matrix[0].length - 1;\n    while (rowBegin <= rowEnd && colBegin <= colEnd) {\n      for (int j = colBegin; j <= colEnd; j++) res.add(matrix[rowBegin][j]);\n      rowBegin++;\n      for (int j = rowBegin; j <= rowEnd; j++) res.add(matrix[j][colEnd]);\n      colEnd--;\n      if (rowBegin <= rowEnd) {\n        for (int j = colEnd; j >= colBegin; j--) res.add(matrix[rowEnd][j]);\n      }\n      rowEnd--;\n      if (colBegin <= colEnd) {\n        for (int j = rowEnd; j >= rowBegin; j--) res.add(matrix[j][colBegin]);\n      }\n      colBegin++;\n    }\n    return res;\n  }\n}` },
        { shortTitle: 'Rotate Image', snippet: `class Solution {\n  public void rotate(int[][] matrix) {\n    for (int i = 0; i < matrix.length; i++) {\n      for (int j = i; j < matrix[0].length; j++) {\n        int temp = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = temp;\n      }\n    }\n    for (int i = 0; i < matrix.length; i++) {\n      for (int j = 0; j < matrix.length / 2; j++) {\n        int temp = matrix[i][j];\n        matrix[i][j] = matrix[i][matrix.length - 1 - j];\n        matrix[i][matrix.length - 1 - j] = temp;\n      }\n    }\n  }\n}` },
        { shortTitle: 'Word Search', snippet: `class Solution {\n  public boolean exist(char[][] board, String word) {\n    for (int i = 0; i < board.length; i++) {\n      for (int j = 0; j < board[0].length; j++) {\n        if (exist(board, i, j, word, 0)) return true;\n      }\n    }\n    return false;\n  }\n  private boolean exist(char[][] board, int i, int j, String word, int idx) {\n    if (idx == word.length()) return true;\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(idx)) return false;\n    char c = board[i][j];\n    board[i][j] = '*';\n    boolean res = exist(board, i+1, j, word, idx+1) || exist(board, i-1, j, word, idx+1) || exist(board, i, j+1, word, idx+1) || exist(board, i, j-1, word, idx+1);\n    board[i][j] = c;\n    return res;\n  }\n}` }
    ],
    'string': [
        { shortTitle: 'Longest Substr Non-Repeat', snippet: `class Solution {\n  public int lengthOfLongestSubstring(String s) {\n    int n = s.length(), ans = 0;\n    Map<Character, Integer> map = new HashMap<>();\n    for (int j = 0, i = 0; j < n; j++) {\n      if (map.containsKey(s.charAt(j))) i = Math.max(map.get(s.charAt(j)), i);\n      ans = Math.max(ans, j - i + 1);\n      map.put(s.charAt(j), j + 1);\n    }\n    return ans;\n  }\n}` },
        { shortTitle: 'Repeating Character Rep', snippet: `class Solution {\n  public int characterReplacement(String s, int k) {\n    int[] counts = new int[26];\n    int maxCount = 0, maxLength = 0, left = 0;\n    for (int right = 0; right < s.length(); right++) {\n      maxCount = Math.max(maxCount, ++counts[s.charAt(right) - 'A']);\n      while (right - left + 1 - maxCount > k) {\n        counts[s.charAt(left) - 'A']--;\n        left++;\n      }\n      maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n  }\n}` },
        { shortTitle: 'Min Window Substring', snippet: `class Solution {\n  public String minWindow(String s, String t) {\n    if (s.length() == 0 || t.length() == 0) return "";\n    Map<Character, Integer> dict = new HashMap<>();\n    for (int i = 0; i < t.length(); i++) dict.put(t.charAt(i), dict.getOrDefault(t.charAt(i), 0) + 1);\n    int required = dict.size(), l = 0, r = 0, formed = 0;\n    Map<Character, Integer> windowCounts = new HashMap<>();\n    int[] ans = {-1, 0, 0};\n    while (r < s.length()) {\n      char c = s.charAt(r);\n      windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);\n      if (dict.containsKey(c) && windowCounts.get(c).intValue() == dict.get(c).intValue()) formed++;\n      while (l <= r && formed == required) {\n        c = s.charAt(l);\n        if (ans[0] == -1 || r - l + 1 < ans[0]) { ans[0] = r - l + 1; ans[1] = l; ans[2] = r; }\n        windowCounts.put(c, windowCounts.get(c) - 1);\n        if (dict.containsKey(c) && windowCounts.get(c).intValue() < dict.get(c).intValue()) formed--;\n        l++;\n      }\n      r++;\n    }\n    return ans[0] == -1 ? "" : s.substring(ans[1], ans[2] + 1);\n  }\n}` },
        { shortTitle: 'Valid Anagram', snippet: `class Solution {\n  public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) return false;\n    int[] table = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n      table[s.charAt(i) - 'a']++;\n      table[t.charAt(i) - 'a']--;\n    }\n    for (int count : table) if (count != 0) return false;\n    return true;\n  }\n}` },
        { shortTitle: 'Group Anagrams', snippet: `class Solution {\n  public List<List<String>> groupAnagrams(String[] strs) {\n    if (strs.length == 0) return new ArrayList<>();\n    Map<String, List<String>> map = new HashMap<>();\n    for (String s : strs) {\n      char[] ca = s.toCharArray();\n      Arrays.sort(ca);\n      String key = String.valueOf(ca);\n      if (!map.containsKey(key)) map.put(key, new ArrayList<>());\n      map.get(key).add(s);\n    }\n    return new ArrayList<>(map.values());\n  }\n}` },
        { shortTitle: 'Valid Parentheses', snippet: `class Solution {\n  public boolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n    for (char c : s.toCharArray()) {\n      if (c == '(') stack.push(')');\n      else if (c == '{') stack.push('}');\n      else if (c == '[') stack.push(']');\n      else if (stack.isEmpty() || stack.pop() != c) return false;\n    }\n    return stack.isEmpty();\n  }\n}` },
        { shortTitle: 'Valid Palindrome', snippet: `class Solution {\n  public boolean isPalindrome(String s) {\n    for (int i = 0, j = s.length() - 1; i < j; i++, j--) {\n      while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n      while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n      if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n    }\n    return true;\n  }\n}` },
        { shortTitle: 'Palindromic Substr', snippet: `class Solution {\n  public int countSubstrings(String s) {\n    int n = s.length(), res = 0;\n    for (int i = 0; i < 2 * n - 1; i++) {\n      int left = i / 2, right = left + i % 2;\n      while (left >= 0 && right < n && s.charAt(left) == s.charAt(right)) {\n        res++; left--; right++;\n      }\n    }\n    return res;\n  }\n}` },
        { shortTitle: 'Longest Palindromic', snippet: `class Solution {\n  public String longestPalindrome(String s) {\n    if (s == null || s.length() < 1) return "";\n    int start = 0, end = 0;\n    for (int i = 0; i < s.length(); i++) {\n      int len1 = expandAroundCenter(s, i, i);\n      int len2 = expandAroundCenter(s, i, i + 1);\n      int len = Math.max(len1, len2);\n      if (len > end - start) {\n        start = i - (len - 1) / 2;\n        end = i + len / 2;\n      }\n    }\n    return s.substring(start, end + 1);\n  }\n  private int expandAroundCenter(String s, int left, int right) {\n    int L = left, R = right;\n    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) { L--; R++; }\n    return R - L - 1;\n  }\n}` }
    ],
    'tree': [
        { shortTitle: 'Max Depth', snippet: `class Solution {\n  public int maxDepth(TreeNode root) {\n    if(root == null) return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n  }\n}` },
        { shortTitle: 'Same Tree', snippet: `class Solution {\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);\n  }\n}` },
        { shortTitle: 'Invert Binary Tree', snippet: `class Solution {\n  public TreeNode invertTree(TreeNode root) {\n    if (root == null) return null;\n    TreeNode left = invertTree(root.left);\n    TreeNode right = invertTree(root.right);\n    root.left = right;\n    root.right = left;\n    return root;\n  }\n}` },
        { shortTitle: 'Max Path Sum', snippet: `class Solution {\n  int max_sum = Integer.MIN_VALUE;\n  public int maxPathSum(TreeNode root) {\n    max_gain(root);\n    return max_sum;\n  }\n  public int max_gain(TreeNode node) {\n    if (node == null) return 0;\n    int left_gain = Math.max(max_gain(node.left), 0);\n    int right_gain = Math.max(max_gain(node.right), 0);\n    int price_newpath = node.val + left_gain + right_gain;\n    max_sum = Math.max(max_sum, price_newpath);\n    return node.val + Math.max(left_gain, right_gain);\n  }\n}` },
        { shortTitle: 'Level Order Travers', snippet: `class Solution {\n  public List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> res = new ArrayList<>();\n    if (root == null) return res;\n    Queue<TreeNode> q = new LinkedList<>();\n    q.add(root);\n    while (!q.isEmpty()) {\n      int levelNum = q.size();\n      List<Integer> subList = new ArrayList<>();\n      for (int i=0; i<levelNum; i++) {\n        if (q.peek().left != null) q.offer(q.peek().left);\n        if (q.peek().right != null) q.offer(q.peek().right);\n        subList.add(q.poll().val);\n      }\n      res.add(subList);\n    }\n    return res;\n  }\n}` },
        { shortTitle: 'Serialize/Deserialize', snippet: `public class Codec {\n  public String serialize(TreeNode root) {\n    if (root == null) return "";\n    Queue<TreeNode> q = new LinkedList<>();\n    StringBuilder res = new StringBuilder();\n    q.add(root);\n    while (!q.isEmpty()) {\n      TreeNode node = q.poll();\n      if (node == null) {\n        res.append("n ");\n        continue;\n      }\n      res.append(node.val + " ");\n      q.add(node.left);\n      q.add(node.right);\n    }\n    return res.toString();\n  }\n  public TreeNode deserialize(String data) {\n    if (data == "") return null;\n    Queue<TreeNode> q = new LinkedList<>();\n    String[] values = data.split(" ");\n    TreeNode root = new TreeNode(Integer.parseInt(values[0]));\n    q.add(root);\n    for (int i = 1; i < values.length; i++) {\n      TreeNode parent = q.poll();\n      if (!values[i].equals("n")) {\n        TreeNode left = new TreeNode(Integer.parseInt(values[i]));\n        parent.left = left;\n        q.add(left);\n      }\n      if (!values[++i].equals("n")) {\n        TreeNode right = new TreeNode(Integer.parseInt(values[i]));\n        parent.right = right;\n        q.add(right);\n      }\n    }\n    return root;\n  }\n}` },
        { shortTitle: 'Subtree of Another', snippet: `class Solution {\n  public boolean isSubtree(TreeNode s, TreeNode t) {\n    if (s == null) return false;\n    if (isSame(s, t)) return true;\n    return isSubtree(s.left, t) || isSubtree(s.right, t);\n  }\n  private boolean isSame(TreeNode s, TreeNode t) {\n    if (s == null && t == null) return true;\n    if (s == null || t == null) return false;\n    if (s.val != t.val) return false;\n    return isSame(s.left, t.left) && isSame(s.right, t.right);\n  }\n}` },
        { shortTitle: 'Const. Tree Pre/In', snippet: `class Solution {\n  public TreeNode buildTree(int[] preorder, int[] inorder) {\n    return helper(0, 0, inorder.length - 1, preorder, inorder);\n  }\n  private TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) {\n    if (preStart > preorder.length - 1 || inStart > inEnd) return null;\n    TreeNode root = new TreeNode(preorder[preStart]);\n    int inIndex = 0;\n    for (int i = inStart; i <= inEnd; i++) {\n      if (inorder[i] == root.val) { inIndex = i; break; }\n    }\n    root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);\n    root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);\n    return root;\n  }\n}` },
        { shortTitle: 'Validate BST', snippet: `class Solution {\n  public boolean isValidBST(TreeNode root) {\n    return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n  }\n  public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\n    if (root == null) return true;\n    if (root.val >= maxVal || root.val <= minVal) return false;\n    return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\n  }\n}` },
        { shortTitle: 'Kth Smallest BST', snippet: `class Solution {\n  public int kthSmallest(TreeNode root, int k) {\n    LinkedList<TreeNode> stack = new LinkedList<TreeNode>();\n    while (true) {\n      while (root != null) { stack.add(root); root = root.left; }\n      root = stack.removeLast();\n      if (--k == 0) return root.val;\n      root = root.right;\n    }\n  }\n}` },
        { shortTitle: 'LCA of BST', snippet: `class Solution {\n  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);\n    if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\n    return root;\n  }\n}` },
        { shortTitle: 'Prefix Tree (Trie)', snippet: `class Trie {\n  class TrieNode {\n    boolean isWord;\n    TrieNode[] children = new TrieNode[26];\n  }\n  private TrieNode root;\n  public Trie() { root = new TrieNode(); }\n  public void insert(String word) {\n    TrieNode node = root;\n    for (char c : word.toCharArray()) {\n      if (node.children[c - 'a'] == null) node.children[c - 'a'] = new TrieNode();\n      node = node.children[c - 'a'];\n    }\n    node.isWord = true;\n  }\n  public boolean search(String word) {\n    TrieNode node = root;\n    for (char c : word.toCharArray()) {\n      if (node.children[c - 'a'] == null) return false;\n      node = node.children[c - 'a'];\n    }\n    return node.isWord;\n  }\n  public boolean startsWith(String prefix) {\n    TrieNode node = root;\n    for (char c : prefix.toCharArray()) {\n      if (node.children[c - 'a'] == null) return false;\n      node = node.children[c - 'a'];\n    }\n    return true;\n  }\n}` },
        { shortTitle: 'Add and Search Word', snippet: `class WordDictionary {\n  class TrieNode {\n    boolean isWord;\n    TrieNode[] children = new TrieNode[26];\n  }\n  private TrieNode root;\n  public WordDictionary() { root = new TrieNode(); }\n  public void addWord(String word) {\n    TrieNode node = root;\n    for (char c : word.toCharArray()) {\n      if (node.children[c - 'a'] == null) node.children[c - 'a'] = new TrieNode();\n      node = node.children[c - 'a'];\n    }\n    node.isWord = true;\n  }\n  public boolean search(String word) {\n    return match(word.toCharArray(), 0, root);\n  }\n  private boolean match(char[] chs, int k, TrieNode node) {\n    if (k == chs.length) return node.isWord;\n    if (chs[k] != '.') {\n      return node.children[chs[k] - 'a'] != null && match(chs, k + 1, node.children[chs[k] - 'a']);\n    } else {\n      for (int i = 0; i < node.children.length; i++) {\n        if (node.children[i] != null) {\n          if (match(chs, k + 1, node.children[i])) return true;\n        }\n      }\n    }\n    return false;\n  }\n}` },
        { shortTitle: 'Word Search II', snippet: `class Solution {\n  public List<String> findWords(char[][] board, String[] words) {\n    List<String> res = new ArrayList<>();\n    TrieNode root = buildTrie(words);\n    for (int i = 0; i < board.length; i++) {\n      for (int j = 0; j < board[0].length; j++) dfs(board, i, j, root, res);\n    }\n    return res;\n  }\n  public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\n    char c = board[i][j];\n    if (c == '#' || p.next[c - 'a'] == null) return;\n    p = p.next[c - 'a'];\n    if (p.word != null) { res.add(p.word); p.word = null; }\n    board[i][j] = '#';\n    if (i > 0) dfs(board, i - 1, j ,p, res);\n    if (j > 0) dfs(board, i, j - 1, p, res);\n    if (i < board.length - 1) dfs(board, i + 1, j, p, res);\n    if (j < board[0].length - 1) dfs(board, i, j + 1, p, res);\n    board[i][j] = c;\n  }\n  class TrieNode {\n    TrieNode[] next = new TrieNode[26];\n    String word;\n  }\n  public TrieNode buildTrie(String[] words) {\n    TrieNode root = new TrieNode();\n    for (String w : words) {\n      TrieNode p = root;\n      for (char c : w.toCharArray()) {\n        int i = c - 'a';\n        if (p.next[i] == null) p.next[i] = new TrieNode();\n        p = p.next[i];\n      }\n      p.word = w;\n    }\n    return root;\n  }\n}` }
    ],
    'heap': [
        { shortTitle: 'Merge K Sorted Lists', snippet: `class Solution {\n  public ListNode mergeKLists(ListNode[] lists) {\n    if (lists == null || lists.length == 0) return null;\n    PriorityQueue<ListNode> pq = new PriorityQueue<>(lists.length, (a, b) -> a.val - b.val);\n    for (ListNode node : lists) if (node != null) pq.add(node);\n    ListNode dummy = new ListNode(0);\n    ListNode tail = dummy;\n    while (!pq.isEmpty()) {\n      tail.next = pq.poll();\n      tail = tail.next;\n      if (tail.next != null) pq.add(tail.next);\n    }\n    return dummy.next;\n  }\n}` },
        { shortTitle: 'Top K Freq. Elements', snippet: `class Solution {\n  public int[] topKFrequent(int[] nums, int k) {\n    HashMap<Integer, Integer> map = new HashMap<>();\n    for (int num : nums) map.put(num, map.getOrDefault(num, 0) + 1);\n    PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n      pq.add(entry);\n      if (pq.size() > k) pq.poll();\n    }\n    int[] res = new int[k];\n    for (int i = k - 1; i >= 0; i--) res[i] = pq.poll().getKey();\n    return res;\n  }\n}` }
    ]
};
